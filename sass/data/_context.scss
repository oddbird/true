@use 'sass:list';
@use 'sass:map';
@use '../config/terms';
@use '../config/throw';

// Context [variable]
// ------------------
/// Stores the current module/test/assertion context stack
/// @access private
/// @group private-context
/// @type list
$context: ();

// Context [mixin]
// ---------------
/// Update the current context for a given scope
/// @access private
/// @group private-context
/// @param {string} $scope -
///   Either `module`, `test` or `assert`
/// @param {string} $name -
///   Name or description of the current scope
@mixin context($scope, $name) {
  $context: list.append($context, ($scope, $name)) !global;
}

// Context Pop [mixin]
// -------------------
/// Remove the deepest context layer from `$context`
/// @access private
/// @group private-context
@mixin context-pop {
  $new: ();

  @for $i from 1 to list.length($context) {
    $new: list.append($new, list.nth($context, $i));
  }

  $context: $new !global;
}

// Output-context [variable]
// -------------------------
/// Make sure every output test
/// includes an `assert`, `output`, and `expect`/`contains`
/// @access private
/// @group private-context
/// @type list
$output-context: ();

// Output-context [mixin]
// ----------------------
/// Add `assert`, `output`, `expect`, or `contains` context to an output test,
/// or check to make sure they all exist before resetting the context.
/// @access private
/// @group private-context
/// @param {'assert' | 'output' | 'expect' | 'contains' | null} $new -
///   Add a new `assert`, `output`, `expect`, or `contains` layer
///   to the context of an output-test,
///   or use `null` to check that all context is properly formed
///   and then reset it at the end of a test
/// @param {list} $context [$output-context] -
///   The current output context
@mixin output-context($new, $context: $output-context) {
  $output-context: validate-output-context($new, $context) !global;
}

// Validate Output-context [function]
// ----------------------------------
/// Validate the new context, and return an updated context value
/// @access private
/// @group private-context
/// @param {'assert' | 'output' | 'expect' | 'contains' | null} $new -
///   Add a new `assert`, `output`, `expect`, or `contains` layer
///   to the context of an output-test,
///   or use `null` to check that all context is properly formed
///   and then reset it at the end of a test
/// @param {list} $context [$output-context] -
///   The current output context
/// @return {list} Updated output context
/// @throw When adding unknown context
/// @throw When trying to add context that already exists
/// @throw When `assert()` is missing before `expect`, `output`, or `contains`
/// @throw When context is missing before a reset
@function validate-output-context($new, $context: $output-context) {
  $valid: map.keys(terms.$output);
  $solo-types: ('expect', 'output');
  $expect-types: ('expect', 'contains', 'contains-string');
  $sub-types: list.append($expect-types, 'output');

  @if $new and not (list.index($valid, $new)) {
    @return throw.error(
      '#{$new} is not a valid context for output tests: #{$valid}',
      'output-context'
    );
  }

  @if list.index($context, $new) {
    @if ($new == 'assert') {
      @return throw.error(
        'The `assert()` mixin can not contain another `assert()`',
        'output-context'
      );
    }

    @if list.index($solo-types, $new) {
      @return throw.error(
        '`#{$new}()` cannot be used multiple times in the same assertion',
        'output-context'
      );
    }

    @return $context;
  }

  @if list.index($sub-types, $new) and not list.index($context, 'assert') {
    @return throw.error(
      '`#{$new}()` is only allowed inside `assert()`',
      'output-context'
    );
  }

  @if list.index($expect-types, $new) {
    @each $step in $context {
      @if list.index($expect-types, $step) and list.index($solo-types, $step) {
        @return throw.error(
          '`#{$new}()` cannot be used in the same assertion as `#{$step}()`',
          'output-context'
        );
      }
    }
  }

  @if $new {
    @return list.append($context, $new);
  }

  // checking and re-setting the context
  @if not list.index($context, 'output') {
    @return throw.error(
      'The `assert()` mixin requires nested `output()`',
      'output-context'
    );
  }

  $has-expect: false;

  @each $expect in $expect-types {
    $has-expect: $has-expect or list.index($context, $expect);
  }

  @if not $has-expect {
    @return throw.error(
      'The `assert()` mixin requires at least one expectation',
      'output-context'
    );
  }

  @if (list.length($context) != 3) {
    @return throw.error(
      'Unexpected assertion stack: #{$context}',
      'output-context'
    );
  }

  @return ();
}

// Context [function]
// ------------------
/// Get information on current context for a given scope
/// @group private-context
/// @param {string} $scope
/// @return {string}
/// @access private
@function context($scope) {
  $value: null;

  @each $entry-scope, $entry-value in $context {
    @if $entry-scope == $scope {
      $value: $entry-value;
    }
  }

  @return $value;
}

// Context All [function]
// ----------------------
/// Get list of context names for a given scope
/// @group private-context
/// @param {string} $scope
/// @return {list}
/// @access private
@function context-all($scope) {
  $list: ();

  @each $entry-scope, $entry-value in $context {
    @if $entry-scope == $scope {
      $list: list.append($list, $entry-value);
    }
  }

  @return $list;
}
